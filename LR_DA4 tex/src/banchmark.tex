\section{Тест производительности}

Тест производительности представляет из себя сравнение времени работы поиска образца в тексте с использованием написанного алгоритма с построением Z-блоков и
функции find для класса std::string из стандартной библиотеки C++. В рассматриваемых тестах слова в тексте и образце состоят из не более чем трёх букв, размер
алфавита – три символа, количество слов в образце составляет десять, а общее число
слов в текстах – сто, десять тысяч, сто тысяч и миллион.

Моя реализация:
\begin{alltt}
(py37) ~ /DA_labs/lab4$ ./banchmark <test100.txt
std::find work time = 0.119ms,z-function work time = 0.235ms.
(py37) ~ /DA_labs/lab4$ ./banchmark <test10000.txt
std::find work time = 10.723ms,z-function work time = 33.491ms.
(py37) ~ /DA_labs/lab4$ ./banchmark <test100000.txt
std::find work time = 170.296ms,z-function work time = 327.8ms.
(py37) ~ /DA_labs/lab4$ ./banchmark <test1000000.txt
std::find work time = 1666.659ms,z-function work time = 3118.58ms.
\end{alltt}

Как видно, у обоих алгоритмов наблюдается почти линейный рост времени работы в зависимости от размера входных данных, однако написанная Z-функция значительно
уступает функции find из стандартной библиотеки. Возможно, это связано с тем, что
используемый алгоритм генерации текстов заполняет их словами алфавита случайным образом, и получается, что в Z-функции используются Z-блоки довольно редко
и их длина сравнительно небольшая, поэтому почти всегда возникает необходимость
искать новые совпадающие с префиксом подстроки, что почти есть работа функции
find, однако в Z-функции выполняется большее число операций из-за проверки на
каждой итерации принадлежности позиции Z-блоку, а также условия на изменение
границ рабочего Z-блока.
По-моему мнению, написанный алгоритм будет работать гораздо эффективнее в
сравнении с find при работе с другими текстами, например такими, которые могут
состоят только из искомого образца и образца с одним различающимся словом, тогда
подстроки будут чаще совпадать с префиксом и Z-блоки будут также использоваться
регулярнее
\pagebreak

